#!/usr/bin/env python3
"""
IA¬≥ INTEGRATOR - Sistema de Integra√ß√£o Total dos Top 10 Sistemas
Conecta todos os sistemas promissores ao n√∫cleo IA¬≥ para emerg√™ncia coletiva
"""

import os
import sys
import time
import json
import logging
import threading
import subprocess
from typing import Dict, List, Any

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("IA3_INTEGRATOR")

class IA3Integrator:
    """Integrador principal dos sistemas IA¬≥"""

    async def __init__(self):
        self.systems = {}
        self.ia3_core = None
        self.integration_status = {}
        self.active_processes = []

    async def initialize_integration(self):
        """Inicializar integra√ß√£o completa"""
        logger.info("üöÄ INICIANDO INTEGRA√á√ÉO IA¬≥ COMPLETA")

        # 1. Importar e conectar sistemas top10
        self.load_top10_systems()

        # 2. Conectar ao n√∫cleo IA¬≥
        self.connect_ia3_core()

        # 3. Iniciar processos paralelos
        self.start_parallel_systems()

        # 4. Ativar comunica√ß√£o entre sistemas
        self.activate_system_communication()

        logger.info("‚úÖ INTEGRA√á√ÉO IA¬≥ COMPLETA - TODOS OS SISTEMAS CONECTADOS")

    async def load_top10_systems(self):
        """Carregar os 10 sistemas mais promissores"""
        systems_to_load = [
            ('REAL_INTELLIGENCE_SYSTEM', 'REAL_INTELLIGENCE_SYSTEM.py', 'IA3System'),
            ('PENIN_OMEGA', 'PENIN_ULTIMATE_SYSTEM.py', 'PENINOmegaSystem'),
            ('TRUE_EMERGENT_INTELLIGENCE', 'true_emergent_intelligence_system.py', 'TrueEmergentIntelligenceSystem'),
            ('NEURAL_GENESIS_IA3', 'NEURAL_GENESIS_IA3.py', 'NeuralGenesisIA3'),
            ('AGENT_BEHAVIOR_LEARNER', 'agent_behavior_learner.py', 'AgentBehaviorLearner'),
            ('EMERGENCE_DETECTOR', 'emergence_detector.py', 'EmergenceDetector'),
            ('BIOLOGICAL_METABOLIZER', 'biological_metabolizer.py', 'BiologicalMetabolizer'),
            ('AUTO_EVOLUTION_ENGINE', 'auto_evolution_engine.py', 'AutoEvolutionEngine'),
            ('SWARM_INTELLIGENCE', 'swarm_intelligence.py', 'SwarmIntelligence'),
            ('QUANTUM_PROCESSING', 'quantum_processing.py', 'QuantumProcessing')
        ]

        for system_name, file_name, class_name in systems_to_load:
            try:
                # Tentar importar o m√≥dulo
                if os.path.exists(file_name):
                    # Usar subprocess para executar sistemas externos
                    self.systems[system_name] = {
                        'file': file_name,
                        'class': class_name,
                        'process': None,
                        'status': 'loaded',
                        'last_heartbeat': time.time()
                    }
                    logger.info(f"‚úÖ {system_name} carregado: {file_name}")
                else:
                    logger.warning(f"‚ö†Ô∏è Arquivo n√£o encontrado: {file_name}")
                    self.systems[system_name] = {
                        'file': None,
                        'class': class_name,
                        'process': None,
                        'status': 'file_not_found'
                    }
            except Exception as e:
                logger.error(f"‚ùå Erro carregando {system_name}: {e}")
                self.systems[system_name] = {
                    'file': file_name,
                    'class': class_name,
                    'process': None,
                    'status': 'error',
                    'error': str(e)
                }

    async def connect_ia3_core(self):
        """Conectar ao n√∫cleo IA¬≥"""
        try:
            from REAL_INTELLIGENCE_SYSTEM import IA3System
            self.ia3_core = IA3System()
            self.ia3_core.initialize_ia3()
            logger.info("üß† N√∫cleo IA¬≥ conectado")
        except Exception as e:
            logger.error(f"‚ùå Erro conectando n√∫cleo IA¬≥: {e}")

    async def start_parallel_systems(self):
        """Iniciar sistemas em processos paralelos"""
        for system_name, system_info in self.systems.items():
            if system_info['file'] and system_info['status'] == 'loaded':
                try:
                    # Iniciar processo separado para cada sistema
                    process = subprocess.Popen([
                        sys.executable, system_info['file'], 'background'
                    ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

                    system_info['process'] = process
                    system_info['status'] = 'running'
                    self.active_processes.append(process)

                    logger.info(f"üöÄ {system_name} iniciado em processo separado (PID: {process.pid})")

                except Exception as e:
                    logger.error(f"‚ùå Erro iniciando {system_name}: {e}")
                    system_info['status'] = 'failed'
                    system_info['error'] = str(e)

    async def activate_system_communication(self):
        """Ativar comunica√ß√£o entre todos os sistemas"""
        logger.info("üì° ATIVANDO COMUNICA√á√ÉO ENTRE SISTEMAS")

        # Conectar cada sistema ao hub de integra√ß√£o do IA¬≥
        if self.ia3_core:
            for system_name, system_info in self.systems.items():
                if system_info['status'] == 'running':
                    try:
                        # Registrar sistema no hub de integra√ß√£o
                        self.ia3_core.integration_hub.connected_systems[system_name] = system_info
                        logger.info(f"üîó {system_name} conectado ao hub IA¬≥")
                    except Exception as e:
                        logger.error(f"‚ùå Erro conectando {system_name} ao hub: {e}")

    async def monitor_systems(self):
        """Monitorar sa√∫de de todos os sistemas"""
        while True:
            try:
                for system_name, system_info in self.systems.items():
                    if system_info['process']:
                        # Verificar se processo ainda est√° ativo
                        if system_info['process'].poll() is not None:
                            # Processo terminou
                            logger.warning(f"‚ö†Ô∏è Processo de {system_name} terminou (c√≥digo: {system_info['process'].poll()})")
                            system_info['status'] = 'stopped'
                        else:
                            system_info['last_heartbeat'] = time.time()

                # Verificar sistemas parados e tentar reiniciar
                for system_name, system_info in self.systems.items():
                    if system_info['status'] == 'stopped' and system_info['file']:
                        logger.info(f"üîÑ Tentando reiniciar {system_name}")
                        self.restart_system(system_name)

                time.sleep(30)  # Verificar a cada 30 segundos

            except Exception as e:
                logger.error(f"Erro no monitoramento: {e}")
                time.sleep(10)

    async def restart_system(self, system_name):
        """Reiniciar sistema parado"""
        system_info = self.systems[system_name]
        try:
            process = subprocess.Popen([
                sys.executable, system_info['file'], 'background'
            ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            system_info['process'] = process
            system_info['status'] = 'running'
            self.active_processes.append(process)

            logger.info(f"‚úÖ {system_name} reiniciado (PID: {process.pid})")

        except Exception as e:
            logger.error(f"‚ùå Falha ao reiniciar {system_name}: {e}")

    async def run_integration_cycle(self):
        """Executar ciclo de integra√ß√£o"""
        if not self.ia3_core:
            return

        try:
            # Executar ciclo IA¬≥
            cycle_result = self.ia3_core.run_ia3_cycle()

            # Compartilhar resultados com outros sistemas
            self.share_cycle_results(cycle_result)

            # Verificar emerg√™ncia coletiva
            if cycle_result.get('emergence_proven', False):
                self.announce_collective_emergence()

            return await cycle_result

        except Exception as e:
            logger.error(f"Erro no ciclo de integra√ß√£o: {e}")
            return await None

    async def share_cycle_results(self, cycle_result):
        """Compartilhar resultados do ciclo com sistemas conectados"""
        for system_name, system_info in self.systems.items():
            if system_info['status'] == 'running':
                try:
                    # Enviar dados para o processo (simplificado)
                    # Em implementa√ß√£o real, usaria pipes, sockets, etc.
                    logger.debug(f"üì§ Compartilhando dados com {system_name}")
                except Exception as e:
                    logger.warning(f"Erro compartilhando com {system_name}: {e}")

    async def announce_collective_emergence(self):
        """Anunciar emerg√™ncia coletiva"""
        logger.info("üéä EMERG√äNCIA COLETIVA ALCAN√áADA!")
        logger.info("üåü TODOS OS SISTEMAS IA¬≥ ATINGIRAM INTELIG√äNCIA EMERGENTE!")
        logger.info("üî• O SISTEMA AGORA √â AUT√îNOMO, IMPAR√ÅVEL E DOMINANTE!")

        # Criar relat√≥rio final
        self.generate_final_report()

    async def generate_final_report(self):
        """Gerar relat√≥rio final da integra√ß√£o IA¬≥"""
        report = {
            'timestamp': time.time(),
            'systems_integrated': len(self.systems),
            'active_systems': len([s for s in self.systems.values() if s['status'] == 'running']),
            'ia3_core_status': self.ia3_core.get_ia3_status() if self.ia3_core else None,
            'emergence_achieved': True,
            'collective_intelligence': 'EMERGENT_AND_DOMINANT'
        }

        with open('IA3_FINAL_REPORT.json', 'w') as f:
            json.dump(report, f, indent=2, default=str)

        logger.info("üìã Relat√≥rio final IA¬≥ gerado: IA3_FINAL_REPORT.json")

    async def get_integration_status(self):
        """Obter status da integra√ß√£o"""
        return await {
            'total_systems': len(self.systems),
            'active_systems': len([s for s in self.systems.values() if s['status'] == 'running']),
            'ia3_core_active': self.ia3_core is not None,
            'processes_running': len(self.active_processes),
            'emergence_status': self.ia3_core.get_ia3_status()['emergence_proven'] if self.ia3_core else False
        }

async def main():
    """Fun√ß√£o principal"""
    integrator = IA3Integrator()

    try:
        # Inicializar integra√ß√£o
        integrator.initialize_integration()

        # Iniciar monitoramento em thread separada
        monitor_thread = threading.Thread(target=integrator.monitor_systems, daemon=True)
        monitor_thread.start()

        # Loop principal de integra√ß√£o
        cycle_count = 0
        while True:
            cycle_result = integrator.run_integration_cycle()
            cycle_count += 1

            if cycle_count % 100 == 0:
                status = integrator.get_integration_status()
                logger.info(f"üîÑ Ciclo de Integra√ß√£o {cycle_count}")
                logger.info(f"   Sistemas ativos: {status['active_systems']}/{status['total_systems']}")
                logger.info(f"   Emerg√™ncia: {status['emergence_status']}")

                # Verificar se todos os sistemas atingiram emerg√™ncia
                if status['emergence_status'] and status['active_systems'] >= 8:
                    integrator.announce_collective_emergence()
                    break

            time.sleep(5)  # Ciclo a cada 5 segundos

    except KeyboardInterrupt:
        logger.info("üõë Integra√ß√£o IA¬≥ interrompida pelo usu√°rio")
    except Exception as e:
        logger.error(f"Erro fatal na integra√ß√£o: {e}")
    finally:
        # Limpar processos
        for process in integrator.active_processes:
            try:
                process.terminate()
            except:
                pass

        logger.info("üèÅ Integra√ß√£o IA¬≥ finalizada")

if __name__ == "__main__":
    main()