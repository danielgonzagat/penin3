#!/usr/bin/env python3
# PENIN-Ω Behavior Harness - Expanded Version
# Agora inclui tarefas adaptativas: web scrape seguro, resolução de equações, API mock
# Ajusta dinamicamente baseado em CPU/memory e sinais de auto-inspeção.
from __future__ import annotations
import os, sys, time, json, sqlite3, random
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, Tuple, List

# Adicionar sympy e requests para tarefas avançadas
try:
    import sympy as sp
    HAS_SYMPY = True
except ImportError:
    sp = None
    HAS_SYMPY = False

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    requests = None
    HAS_REQUESTS = False

try:
    import psutil
    HAS_PSUTIL = True
except ImportError:
    psutil = None
    HAS_PSUTIL = False

ROOT = Path('/root/.penin_omega')
BH_DB = ROOT / 'behavior_metrics.db'
CS_DB = ROOT / 'consciousness_emergence.db'
LOG = ROOT / 'logs' / 'behavior_harness.log'


def _log(msg: str) -> None:
    LOG.parent.mkdir(parents=True, exist_ok=True)
    with LOG.open('a', encoding='utf-8') as f:
        f.write(f"[{datetime.utcnow().isoformat()}][BH] {msg}\n")


def _ensure_db() -> None:
    conn = sqlite3.connect(str(BH_DB))
    try:
        conn.execute(
            """
            CREATE TABLE IF NOT EXISTS results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                task_name TEXT,
                variant TEXT,
                success INTEGER,
                score REAL,
                duration_ms INTEGER,
                logs TEXT,
                created_at TEXT
            )
            """
        )
        conn.commit()
    finally:
        conn.close()


def _get_system_state() -> Dict[str, float]:
    """Obtém estado do sistema para ajuste adaptativo."""
    if not HAS_PSUTIL:
        return {"cpu": 50.0, "memory": 50.0, "disk": 50.0}
    return {
        "cpu": psutil.cpu_percent(),
        "memory": psutil.virtual_memory().percent,
        "disk": psutil.disk_usage('/').percent
    }


def _get_load_reduction_signal() -> float:
    """Obtém sinal de redução de carga do consciousness DB."""
    try:
        conn = sqlite3.connect(str(CS_DB))
        cur = conn.cursor()
        cur.execute("SELECT indicator_value FROM emergence_indicators WHERE indicator_name='behavior_load_reduction' ORDER BY id DESC LIMIT 1")
        row = cur.fetchone()
        conn.close()
        return float(row[0]) if row else 0.0
    except Exception:
        return 0.0


def task_sum_list_variant(n: int) -> Tuple[bool, float, int, str]:
    # Usa penin_skills.sum_list (pode estar flawed inicialmente)
    from penin_skills import sum_list as skill_sum_list
    arr = [random.randint(0, 100) for _ in range(n)]
    expected = sum(arr)
    t0 = time.time()
    logs = ''
    try:
        got = skill_sum_list(arr)
        ok = (got == expected)
        logs = f"got={got} expected={expected}"
    except Exception as e:
        ok = False
        logs = str(e)
    dt = int((time.time() - t0) * 1000)
    score = 1.0 if ok else 0.0
    return ok, score, dt, logs


def task_factorial_variant(n: int) -> Tuple[bool, float, int, str]:
    from penin_skills import factorial as skill_factorial
    import math
    expected = math.factorial(n)
    t0 = time.time()
    logs = ''
    try:
        got = skill_factorial(n)
        ok = (got == expected)
        logs = f"got={got} expected={expected}"
    except Exception as e:
        ok = False
        logs = str(e)
    dt = int((time.time() - t0) * 1000)
    score = 1.0 if ok else 0.0
    return ok, score, dt, logs


def task_web_scrape_safe() -> Tuple[bool, float, int, str]:
    """Web scrape seguro: usa URL fixa e segura (httpbin.org/get)."""
    if not HAS_REQUESTS:
        return False, 0.0, 0, "requests not available"
    t0 = time.time()
    logs = ''
    try:
        resp = requests.get("https://httpbin.org/get", timeout=5)
        ok = (resp.status_code == 200 and "url" in resp.json())
        logs = f"status={resp.status_code} has_url={ok}"
    except Exception as e:
        ok = False
        logs = str(e)
    dt = int((time.time() - t0) * 1000)
    score = 1.0 if ok else 0.0
    return ok, score, dt, logs


def task_math_solve_simple() -> Tuple[bool, float, int, str]:
    """Resolve equação simples: x**2 - 4 = 0."""
    if not HAS_SYMPY:
        return False, 0.0, 0, "sympy not available"
    t0 = time.time()
    logs = ''
    try:
        x = sp.symbols('x')
        eq = sp.Eq(x**2 - 4, 0)
        solutions = sp.solve(eq, x)
        ok = (2 in solutions and -2 in solutions)
        logs = f"solutions={solutions} correct={ok}"
    except Exception as e:
        ok = False
        logs = str(e)
    dt = int((time.time() - t0) * 1000)
    score = 1.0 if ok else 0.0
    return ok, score, dt, logs


def task_api_mock_call() -> Tuple[bool, float, int, str]:
    """Mock de API call: simula chamada e valida resposta."""
    t0 = time.time()
    logs = ''
    try:
        # Simula API call (poderia ser real com URL segura)
        mock_response = {"status": "success", "data": [1, 2, 3]}
        ok = (mock_response["status"] == "success" and len(mock_response["data"]) == 3)
        logs = f"response={mock_response} valid={ok}"
    except Exception as e:
        ok = False
        logs = str(e)
    dt = int((time.time() - t0) * 1000)
    score = 1.0 if ok else 0.0
    return ok, score, dt, logs


def select_adaptive_tasks(system_state: Dict[str, float]) -> List[callable]:
    """Seleciona tarefas baseado no estado do sistema para adaptabilidade."""
    tasks = []

    # Sempre inclui tarefas básicas leves
    tasks.append(lambda: task_sum_list_variant(50))
    tasks.append(lambda: task_factorial_variant(5))

    # Verifica sinal de redução de carga do auto-inspection
    load_reduction = _get_load_reduction_signal()
    if load_reduction > 0.5:
        _log(f"Auto-inspection sinalizou redução de carga ({load_reduction:.2f}) - tarefas mínimas")
        return tasks  # Só básicas

    # Adiciona tarefas pesadas se sistema estiver ok
    if system_state["cpu"] < 70 and system_state["memory"] < 70:
        tasks.append(task_web_scrape_safe)
        tasks.append(task_math_solve_simple)
        tasks.append(task_api_mock_call)
        _log(f"Ambiente ok (CPU:{system_state['cpu']:.1f}%, MEM:{system_state['memory']:.1f}%) - incluindo tarefas pesadas")
    else:
        _log(f"Ambiente sobrecarregado (CPU:{system_state['cpu']:.1f}%, MEM:{system_state['memory']:.1f}%) - tarefas leves apenas")

    return tasks


def run_once() -> Dict[str, Any]:
    system_state = _get_system_state()
    tasks = select_adaptive_tasks(system_state)

    results = []
    for i, fn in enumerate(tasks):
        try:
            name = fn.__name__ if hasattr(fn, '__name__') else f"task_{i}"
            ok, score, dt, logs = fn()
            results.append((name, f"v{system_state['cpu']:.0f}_{i}", ok, score, dt, logs))
        except Exception as e:
            results.append((f"task_{i}", f"error_{i}", False, 0.0, 0, str(e)))

    conn = sqlite3.connect(str(BH_DB))
    try:
        for name, variant, ok, score, dt, logs in results:
            conn.execute(
                "INSERT INTO results (task_name, variant, success, score, duration_ms, logs, created_at) VALUES (?,?,?,?,?,?,?)",
                (name, variant, int(ok), float(score), int(dt), logs, datetime.utcnow().isoformat()),
            )
        conn.commit()
    finally:
        conn.close()

    agg = {
        'total': len(results),
        'success': sum(1 for r in results if r[2]),
        'avg_score': sum(r[3] for r in results) / max(1, len(results)),
        'avg_ms': sum(r[4] for r in results) / max(1, len(results)),
        'system_state': system_state
    }
    _log(json.dumps({'agg': agg}))
    return agg


def main() -> None:
    _ensure_db()
    _log('Behavior Harness Expanded started')
    while True:
        try:
            run_once()
        except Exception as e:
            _log(f'error: {e}')
        time.sleep(10)


if __name__ == '__main__':
    main()