#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
PENIN-Œ© ¬∑ Bridge 8/8 (CORRIGIDO)
================================
Vers√£o corrigida usando classes unificadas.
"""

from __future__ import annotations
import asyncio
import json
import time
import logging
from dataclasses import asdict
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional

# IMPORT DAS CLASSES UNIFICADAS - CORRE√á√ÉO CR√çTICA
from penin_omega_unified_classes import (
    Candidate, PlanOmega, UnifiedOmegaState, MutationBundle, 
    ExecutionBundle, AcquisitionReport, create_plan_omega, create_unified_state
)

# =============================================================================
# CONFIGURA√á√ÉO
# =============================================================================

PENIN_OMEGA_ROOT = Path("/root/.penin_omega")
LOGS_PATH = PENIN_OMEGA_ROOT / "logs"
LOGS_PATH.mkdir(parents=True, exist_ok=True)

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s][PENIN-Œ©-Bridge-Fixed][%(levelname)s] %(message)s',
    handlers=[
        logging.FileHandler(LOGS_PATH / "penin_omega_bridge_fixed.log"),
        logging.StreamHandler()
    ]
)

# =============================================================================
# BRIDGE CORRIGIDO
# =============================================================================

class PeninOmegaBridgeFixed:
    """Bridge corrigido usando classes unificadas."""
    
    def __init__(self):
        self.state = create_unified_state()
        self.modules = {}
        self.logger = logging.getLogger("PeninOmegaBridge")
        
    async def execute_pipeline_fixed(self, pipeline_id: str = None) -> Dict[str, Any]:
        """
        Executa pipeline completo usando classes unificadas.
        CORRE√á√ÉO: Usa factory functions para criar objetos com par√¢metros corretos.
        """
        if pipeline_id is None:
            pipeline_id = f"pipeline_{int(time.time())}"
            
        self.logger.info(f"üöÄ Iniciando pipeline corrigido {pipeline_id}")
        
        try:
            # F3: Aquisi√ß√£o (simulado)
            self.logger.info(f"üìö F3: Aquisi√ß√£o de conhecimento - {pipeline_id}")
            f3_result = {
                "knowledge_items": [],
                "quality_score": 0.0,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            # F4: Muta√ß√£o (simulado)
            self.logger.info(f"üß¨ F4: Muta√ß√£o e gera√ß√£o - {pipeline_id}")
            f4_candidates = []
            for i in range(3):
                # Usa factory function - CORRE√á√ÉO CR√çTICA
                candidate = Candidate(
                    cand_id=f"cand_{pipeline_id}_{i}",
                    patches={"type": f"mutation_{i}"},
                    metadata={"source": "f4_generation"},
                    score=0.5 + (i * 0.1),
                    notes=f"Generated by F4 for {pipeline_id}"
                )
                f4_candidates.append(candidate.to_dict())
            
            f4_result = {
                "candidates": f4_candidates,
                "diversity_score": 0.7,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            # F5: Crisol (usando m√≥dulo corrigido)
            self.logger.info(f"‚öñÔ∏è  F5: Avalia√ß√£o no crisol - {pipeline_id}")
            try:
                from penin_omega_5_crucible_fixed import crucible_evaluate_and_select
                f5_result = crucible_evaluate_and_select(
                    context={"pipeline_id": pipeline_id},
                    candidates=f4_candidates,
                    goals=[{"name": "optimization", "weight": 1.0}]
                )
            except ImportError:
                # Fallback se m√≥dulo n√£o dispon√≠vel
                f5_result = {
                    "verdict": "ALLOW",
                    "selected_candidates": f4_candidates[:2],
                    "metrics": {"fallback": True}
                }
            
            # F6: Auto-rewrite (simulado)
            self.logger.info(f"üîÑ F6: Auto-rewrite - {pipeline_id}")
            f6_result = {
                "verdict": "ALLOW",
                "patches_applied": len(f5_result.get("selected_candidates", [])),
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            # Cria estado unificado - CORRE√á√ÉO CR√çTICA
            omega_state = create_unified_state(
                rho=0.36, 
                sr_score=0.89, 
                ece=0.002, 
                ppl_ood=94.0,
                consent=True, 
                eco_ok=True, 
                uncertainty=0.10, 
                delta_linf=0.018,
                pipeline_status="completed"
            )
            
            # Cria plano usando factory function - CORRE√á√ÉO CR√çTICA
            plan_omega = create_plan_omega(
                plan_id=f"plan_{pipeline_id}",
                constraints={"rho_max": 0.95, "sr_tau": 0.80, "ece_max": 0.01},
                budgets={"max_cost": 2.0, "max_latency_ms": 60000},
                promotion_policy={"auto_promote": True},
                policies={"safety_first": True},  # Campo que estava causando erro
                rationale=f"Pipeline {pipeline_id} - F6: {f6_result.get('verdict', 'N/A')}"
            )
            
            # Cria bundle de execu√ß√£o
            execution_bundle = ExecutionBundle(
                bundle_id=f"exec_{pipeline_id}",
                artifacts=[
                    {"stage": "F3", "data": f3_result},
                    {"stage": "F4", "data": f4_result},
                    {"stage": "F5", "data": f5_result},
                    {"stage": "F6", "data": f6_result}
                ],
                metrics={
                    "total_time": time.time(),
                    "success_rate": 1.0,
                    "pipeline_id": pipeline_id
                }
            )
            
            # F8: Governan√ßa (simulado)
            self.logger.info(f"üèõÔ∏è  F8: Governan√ßa - {pipeline_id}")
            f8_result = {
                "governance_verdict": "APPROVED",
                "bundle_id": execution_bundle.bundle_id,
                "state": omega_state.to_dict(),
                "plan": plan_omega.to_dict(),
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            # Resultado final
            pipeline_result = {
                "pipeline_id": pipeline_id,
                "status": "SUCCESS",
                "stages": {
                    "F3": f3_result,
                    "F4": f4_result, 
                    "F5": f5_result,
                    "F6": f6_result,
                    "F8": f8_result
                },
                "execution_bundle": execution_bundle.to_dict(),
                "final_state": omega_state.to_dict(),
                "timestamp": datetime.now(timezone.utc).isoformat()
            }
            
            self.logger.info(f"‚úÖ Pipeline {pipeline_id} conclu√≠do com sucesso")
            
            # Salva resultado
            results_file = LOGS_PATH / f"pipeline_{pipeline_id}_result.json"
            with open(results_file, 'w') as f:
                json.dump(pipeline_result, f, indent=2)
            
            return pipeline_result
            
        except Exception as e:
            self.logger.error(f"‚ùå Pipeline {pipeline_id} falhou: {e}")
            return {
                "pipeline_id": pipeline_id,
                "status": "FAILED",
                "error": str(e),
                "timestamp": datetime.now(timezone.utc).isoformat()
            }

# =============================================================================
# FUN√á√ÉO DE TESTE
# =============================================================================

async def test_bridge_fixed():
    """Testa o bridge corrigido."""
    bridge = PeninOmegaBridgeFixed()
    result = await bridge.execute_pipeline_fixed("test_pipeline")
    
    print(f"‚úÖ Teste do bridge: {result['status']}")
    if result['status'] == 'SUCCESS':
        print(f"üìä Est√°gios conclu√≠dos: {list(result['stages'].keys())}")
    else:
        print(f"‚ùå Erro: {result.get('error', 'Unknown')}")
    
    return result

if __name__ == "__main__":
    asyncio.run(test_bridge_fixed())
